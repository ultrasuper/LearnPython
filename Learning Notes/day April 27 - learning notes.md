day April 27 - learning notes

1. 冒泡排序：时间复杂度O(n2)

2. 二分查找：

   时间复杂度O(log(n))

3. 大O表示法：并非以秒为单位的时间，而是比较操作数，指出了算法运行时间的增速

   1. 大O表示法指出了最坏的运行时间
   2. O(log(n)), O(n), O(n*log(n)), O(n2), O(n!)

4. 数组元素占用内存空间是连续的

5. 链表适合做插入和删除，数组适合做读取，数组支持随机访问

6.  相比循环，递归并没有性能上的优势，只是更容易理解，甚至循环可以取得更好的性能

7. 递归有基线条件和递归条件，基线条件就是使递归终止的条件

8. 调用栈

   - 调用另一个函数时，当前函数暂停并处于未完成状态，函数的所有变量还在内存中

9. 尾递归：

   1. 参数表中除了迭代的列表（对象），还有一个额外的参数；
   2. 返回的是递归函数本身，没有其他运算

10. 分治策略——快速排序

    1. 基准值 pivot
    2. 递归：归纳证明
    3. 快排-平均复杂度是O(n*log(n))，最糟是O(n2)

11. 算法运行时间

    1. c是算法所需的固定时间量，被称为常量

12. 简单查找，时间复杂度是O(n)，二分查找，时间复杂度是O(log(n))

13. 分治策略将问题逐步分解，处理列表时，基线条件常常是空列表或者只有一个元素的列表

14. 实现快速排序，要随机的选择作为基准的元素，这样可以取得最优性能，O(nlog(n))

15. 大O表示法，有时候常量很关键

16. 散列表也被称为散列映射、映射、字典和关联数组。

17. 散列表的性能是常量时间O(1)，因为它结合了数组的查找（随机访问）和链表的插入和删除的优点

18. 广度优先搜索：（图的查找算法）

    1. 节点node， 边edge
    2. 先找一度关系，再找二度关系，以此类推
    3. 队列queue
    4. 散列表，表示图的数据结构
    5. 有向图(directed graph)，邻居关系是单向的；无向图(undirected graph), 邻居是双向的

19. 树是一种特殊的图，没有向后指的边

20. 面临类似于寻找最短路径的问题时，可尝试使用图来建立模型，再使用广度优先搜索来
    解决问题。

21. 无向图中的边不带箭头，其中的关系是双向的

22. 队列是先进先出（FIFO）

23. 栈是后进先出（LIFO）

24. 你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必
    须是队列。

25. 对于检查过的人，务必不要再去检查，否则可能导致无限循环。

26. 广度优先中的最短路径是段数最少

27. 无向图中两个节点彼此指向对方，其实就是环，即：无向图中每一条边都是环

28. 迪杰斯特拉算法适用于有向无环图

29. 迪杰斯特拉算法不适合有负权边的图



---

**迪杰斯特拉算法实现过程：**

1. 先画出加权有向图的结构图示
2. 根据1中图示定义3个数据结构和一个统计列表：
   1. 图本身的数据结构
   2. 到每个节点的最小代价的表
   3. 每个节点的父节点的表
   4. 新建一个空列表用于保存已经统计过的到起点最小开销的点
3. 写出算法的主要流程，尤其是算法的终止条件和递归条件
4. 用代码实现终止条件和递归过程

---

